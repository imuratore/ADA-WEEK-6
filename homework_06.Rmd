---
title: "homework 04"
author: "Isabella Muratore"
output:
  html_document: default
  html_notebook: default
---
# homework 04

## [1] Write a simple R function, Z.prop.test(), that can perform one- or two-sample Z-tests for proportion data, using the following guidelines.

### This function has 6 possible outcomes in terms of the settings used for calculations depending on whether this is a two sample or one sample test (based on how many arguments are handed) and whether the test is two-sided, greater than or less than. It returns a list of Z, P, and confidence intervals.
```{r}
# p1/p2 are vectors of values for one or more samples. n1/n2 are the sizes of the samples. p0 is used for comparison in a one-sided test. 
Z.prop.test <- function(p1,p2=NULL,n1,n2=NULL,p0,alternative="two.sided",correct=TRUE,conf.level=0.95){
  if (alternative == "two.sided"){
    if (is.null(p2) | is.null(n2)){
      phat <- mean(p1)
      
      if ((n1*phat1<5) | (n1*(1−phat1)<5)){
        #testing sample size
        message("Warning, n*p and n*p-1 should be greater than 5")
      }
      #two-sided test with one sample
      phat <- mean(p1)
      
      z <- (phat - p0)/sqrt(p0 * (1 - p0)/n1)

      p <- 1- pnorm(z, lower.tail = TRUE) + pnorm(z, lower.tail = FALSE)

      lower <- phat - qnorm(conf.level) * sqrt(phat * (1 - phat)/n1)
      upper <- phat + qnorm(conf.level) * sqrt(phat * (1 - phat)/n1)
      ci <- c(lower, upper)

    } else {

      phat1 <- mean(p1)

      phat2 <- mean(p2)
      
      if ((n1*phat1<5) || (n1*(1−phat1)<5) || (n2*phat2<5) || (n2*(1−phat2)<5)){
        message("Warning, n*p and n*p-1 should be greater than 5")
      }
      #two-sided test with two samples
      
      pstar <- (sum(p1) + sum(p2))/(n1 + n2)

      phat1 <- mean(p1)

      phat2 <- mean(p2)

      z <- (phat1 - phat2)/sqrt((pstar * (1 - pstar)) * (1/n1 + 1/n2))

      p <- 1- pnorm(z, lower.tail = TRUE) + pnorm(z, lower.tail = FALSE)

        lower <- (phat2-phat1) - qnorm(conf.level) * sqrt(phat1*(1-phat1)/n1+phat2*(1-phat2)/n2)
        upper <- (phat2-phat1) + qnorm(conf.level) * sqrt(phat1*(1-phat1)/n1+phat2*(1-phat2)/n2)
      ci <- c(lower, upper)

    } 
    
  } else {
    if (is.null(p2) | is.null(n2)){
      phat <- mean(p1)
      if ((n1*p1<5) | (n1*(1−p1)<5)){
        message("Warning, n*p and n*p-1 should be greater than 5")
      }
      if (alternative == "greater"){
        #prop.test(x = p1, n = n1, p = p0, alternative = alternative, correct = correct)
        phat <- mean(p1)
        
        z <- (phat - p0)/sqrt(p0 * (1 - p0)/n1)

        p <- pnorm(z, lower.tail = FALSE)

        lower <- phat - qnorm(conf.level) * sqrt(phat * (1 - phat)/n1)
        upper <- phat + qnorm(conf.level) * sqrt(phat * (1 - phat)/n1)
        ci <- c(lower, upper)

      } else {
        #prop.test(x = p1, n = n1, p = p0, alternative = alternative, correct = correct)
        phat <- mean(p1)
        
        z <- (phat - p0)/sqrt(p0 * (1 - p0)/n1)

        p <- pnorm(z, lower.tail = TRUE)

        lower <- phat - qnorm(conf.level) * sqrt(phat * (1 - phat)/n1)
        upper <- phat + qnorm(conf.level) * sqrt(phat * (1 - phat)/n1)
        ci <- c(lower, upper)

      }
      
    } else {
      phat1 <- mean(p1)

      phat2 <- mean(p2)
      
      if ((n1*p1<5) || (n1*(1−p1)<5) || (n2*p2<5) || (n2*(1−p2)<5)){
        message("Warning, n*p and n*p-1 should be greater than 5")
      }
      #prop.test(x = c(p1, p2), n = c(n1, n2), alternative = alternative, correct = correct)
      if (alternative == "greater"){
        pstar <- (sum(p1) + sum(p2))/(n1 + n2)

        phat1 <- mean(p1)

        phat2 <- mean(p2)

        z <- (phat1 - phat2)/sqrt((pstar * (1 - pstar)) * (1/n1 + 1/n2))

        p <- pnorm(z, lower.tail = FALSE)

        lower <- (phat2-phat1) - qnorm(conf.level) * sqrt(phat1*(1-phat1)/n1+phat2*(1-phat2)/n2)
        upper <- (phat2-phat1) + qnorm(conf.level) * sqrt(phat1*(1-phat1)/n1+phat2*(1-phat2)/n2)
        ci <- c(lower, upper)
      } else{
        pstar <- (sum(p1) + sum(p2))/(n1 + n2)

        phat1 <- mean(p1)

        phat2 <- mean(p2)

        z <- (phat1 - phat2)/sqrt((pstar * (1 - pstar)) * (1/n1 + 1/n2))

        p <- pnorm(z, lower.tail = TRUE)
        
        lower <- (phat2-phat1) - qnorm(conf.level) * sqrt(phat1*(1-phat1)/n1+phat2*(1-phat2)/n2)
        upper <- (phat2-phat1) + qnorm(conf.level) * sqrt(phat1*(1-phat1)/n1+phat2*(1-phat2)/n2)
        ci <- c(lower, upper)
      }

    }
    
  }
  
  output <- list("z", z, "p", p, "ci", ci)
  output
  
}

```
## The dataset from Kamilar and Cooper has in it a large number of variables related to life history and body size. For this exercise, the end aim is to fit a simple linear regression model to predict longevity (MaxLongevity_m) measured in months from species’ brain size (Brain_Size_Species_Mean) measured in grams. Do the following for both longevity~brain size and log(longevity)~log(brain size)


```{r}

library(curl)
library(ggplot2)
f <- curl("https://raw.githubusercontent.com/fuzzyatelin/fuzzyatelin.github.io/master/AN597_Fall17/KamilarAndCooperData.csv")
d <- read.csv(f, header = TRUE, sep = ",", stringsAsFactors = FALSE)
m <- lm(MaxLongevity_m ~ Brain_Size_Species_Mean, data = d)
g <- ggplot(data = d, aes(x = Brain_Size_Species_Mean, y = MaxLongevity_m))
g <- g + geom_point()
g <- g + geom_smooth(method = "lm", formula = y ~ x, level=0.90)
g <- g + geom_smooth(method = "lm", formula = y ~ x, level=0.90)
g <- g + annotate("text", x=300, y=350, label= "y = 1.218*x + 248.952")
g
```

```{r}
m

# β1 (slope coefficient) = 0.2341
```
###
```{r}
library(lmodel2)

mI <- confint.lm(object=m, level=0.80)

mI

#taking slope stats

ci <- c(1.076163, 1.359817)

ci
```

```{r}
m <- lm(MaxLongevity_m ~ Brain_Size_Species_Mean, data = d)

ci_800 <- predict(m, newdata = data.frame(Brain_Size_Species_Mean = 800), interval = "confidence", 
    level = 0.90) 

ci_800

```


```{r}

m <- lm(log(MaxLongevity_m) ~ log(Brain_Size_Species_Mean), data = d)
g <- ggplot(data = d, aes(x = log(Brain_Size_Species_Mean), y = log(MaxLongevity_m)))
g <- g + geom_point()
g <- g + geom_smooth(method = "lm", formula = y ~ x, level=0.90)
g <- g + annotate("text", x=3.75, y=5, label= "y = 0.2341*x + 4.8790")
g 
```
###
```{r}
m

# β1 (slope coefficient) = 0.2341
```
###
```{r}
mI <- confint.lm(object=m, level=0.80)

mI

#taking slope stats

ci <- c(0.2112063, 0.2570929)

ci
```

```{r}
m <- lm(log(MaxLongevity_m) ~ log(Brain_Size_Species_Mean), data = d)

ci_800 <- predict(m, newdata = data.frame(Brain_Size_Species_Mean = 800), interval = "confidence", 
    level = 0.90) 

ci_800

```


